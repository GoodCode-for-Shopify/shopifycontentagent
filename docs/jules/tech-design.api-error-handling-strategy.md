# Technical Design Document: Global API Error Handling Strategy

## 1. Introduction & Goals

### 1.1. Purpose of this Document
This Technical Design Document (TDD) defines a standardized API error handling strategy for all backend services within the "Content Agent" project, including:
*   Node.js/Express backend for the Admin Dashboard (Firebase Cloud Functions).
*   Node.js/Express backend for the Shopify App (Firebase Cloud Functions).
*   Interactions with the Python PAA service.

The goal is to ensure consistent error responses, clear communication of issues to API consumers (frontend applications or other services), and robust logging for debugging and monitoring.

### 1.2. The Need for a Standardized Strategy
In a distributed system with multiple frontend applications and backend services, a consistent approach to error handling is crucial for:
*   **Developer Experience:** Predictable error formats simplify frontend development and debugging.
*   **User Experience:** Allows frontends to display meaningful and consistent error messages to users.
*   **Monitoring & Logging:** Standardized error logging aids in quickly identifying and diagnosing issues.
*   **Scalability & Maintainability:** A clear strategy makes it easier to manage errors as the application grows.

### 1.3. Key Design Goals
1.  **Standardized Error Response Format:** Define a consistent JSON structure for error responses.
2.  **Appropriate HTTP Status Codes:** Utilize HTTP status codes correctly to indicate the nature of the error.
3.  **Actionable Error Messages:** Provide error messages that are useful for both developers (during debugging) and potentially end-users (when displayed by the frontend).
4.  **Comprehensive Logging:** Ensure all errors are logged with sufficient context for diagnosis.
5.  **Graceful Degradation:** Enable frontends to handle errors gracefully and maintain functionality where possible.
6.  **Security:** Avoid leaking sensitive information (like stack traces or internal system details) in error responses to clients, especially in production.

## 2. Standardized Error Response Format

All API error responses should conform to the following JSON structure:

```json
{
  "error": {
    "code": "ERROR_CODE_IDENTIFIER", // Application-specific error code
    "message": "A human-readable message describing the error.", // For developers or safe for users
    "details": [ // Optional: for more specific, structured error information
      {
        "field": "fieldName", // If error is related to a specific input field
        "issue": "Description of the issue with the field."
      }
      // ... more details objects ...
    ],
    "type": "ErrorType", // e.g., "Validation Error", "Authentication Error", "ThirdPartyAPIError"
    "requestId": "unique-request-id" // Optional, for tracing in logs
  }
}
```

*   **`error.code` (String, Required):** An application-specific, unique error code (e.g., `VALIDATION_ERROR`, `UNAUTHENTICATED`, `STRIPE_PAYMENT_FAILED`, `GOOGLE_ADS_API_ERROR`, `PAA_SERVICE_UNAVAILABLE`). These codes allow frontends to programmatically handle specific errors if needed. As the system evolves, maintaining a central registry or enum of defined `ERROR_CODE_IDENTIFIER`s is recommended for consistency.
*   **`error.message` (String, Required):** A human-readable message. This message should be safe to display to end-users if no more specific frontend message is available. For sensitive errors, it might be more generic in production.
*   **`error.details` (Array of Objects, Optional):** Provides more specific, structured information, especially for validation errors affecting multiple fields. Each object can contain:
    *   `field`: The name of the input field causing the error.
    *   `issue`: A description of what's wrong with that field.
*   **`error.type` (String, Optional):** A broader classification of the error type.
*   **`error.requestId` (String, Optional):** A unique ID for the request, useful for correlating frontend error reports with backend logs. This can be generated by a middleware.

**Note on Simplicity for Python PAA Service:** While the Python PAA service should aim for this, its direct error responses (if not wrapped by the Node.js backend) might be simpler, but should still clearly indicate an error state vs. a successful empty result. If the Node.js backend proxies or calls the PAA service, it should transform PAA errors into this standard format.

## 3. HTTP Status Code Usage

HTTP status codes should be used semantically:

*   **`400 Bad Request`:** For client-side errors, typically validation failures.
    *   `error.code` examples: `VALIDATION_ERROR`, `INVALID_INPUT_FORMAT`.
    *   Use `error.details` to list specific field issues.
*   **`401 Unauthorized`:** For authentication failures (e.g., missing, invalid, or expired session token/API key).
    *   `error.code` examples: `UNAUTHENTICATED`, `TOKEN_EXPIRED`, `INVALID_API_KEY`.
    *   **Important:** Do not include details about why authentication failed if it could reveal sensitive information (e.g., "user not found" vs. "invalid credentials" can be a security risk).
*   **`403 Forbidden`:** When the authenticated user does not have permission to perform the requested action.
    *   `error.code` examples: `INSUFFICIENT_PERMISSIONS`, `PLAN_LIMIT_EXCEEDED`.
*   **`404 Not Found`:** When a requested resource does not exist.
    *   `error.code` examples: `RESOURCE_NOT_FOUND`.
*   **`409 Conflict`:** When a request conflicts with the current state of the resource (e.g., trying to create a resource that already exists with a unique constraint).
    *   `error.code` examples: `RESOURCE_CONFLICT`, `DUPLICATE_ENTRY`.
*   **`422 Unprocessable Entity`:** Similar to 400, but specifically when the server understands the content type of the request entity, and the syntax of the request entity is correct, but it was unable to process the contained instructions (e.g., semantic errors in the input). Often used for more complex validation issues not tied to a single field's syntax.
*   **`429 Too Many Requests`:** For rate limiting.
    *   `error.code` examples: `RATE_LIMIT_EXCEEDED`.
    *   Include `Retry-After` header if possible.
*   **`500 Internal Server Error`:** For unexpected server-side errors. This should be a catch-all.
    *   `error.code` examples: `INTERNAL_SERVER_ERROR`, `DATABASE_ERROR`.
    *   `error.message` in production should be generic (e.g., "An unexpected error occurred. Please try again later."). Detailed error information should only be in logs.
*   **`502 Bad Gateway`:** If a backend service receives an invalid response from an upstream server (e.g., a third-party API like Stripe or Google Ads, or the Python PAA service).
    *   `error.code` examples: `STRIPE_API_ERROR`, `GOOGLE_ADS_API_UNAVAILABLE`, `PAA_SERVICE_ERROR`.
*   **`503 Service Unavailable`:** If the server is temporarily unable to handle the request due to overload or maintenance.
    *   `error.code` examples: `SERVICE_UNAVAILABLE`, `MAINTENANCE_MODE`.
    *   Include `Retry-After` header if possible.

## 4. Error Handling Middleware (Node.js/Express Example)

A common approach in Express is to use centralized error handling middleware.

```javascript
// Conceptual Express error handling middleware
// Placed after all other app.use() and routes

// Utility to create a standardized error object
const createApiError = (statusCode, errorCode, message, details = [], type = "GenericError") => {
  const error = new Error(message);
  error.statusCode = statusCode;
  error.errorCode = errorCode;
  error.errorDetails = details;
  error.errorType = type;
  return error;
};

// Custom error classes
class ValidationError extends Error {
  constructor(message, details) {
    super(message);
    this.name = "ValidationError";
    this.statusCode = 400;
    this.errorCode = "VALIDATION_ERROR";
    this.errorDetails = details;
    this.errorType = "Validation Error";
  }
}
// ... other custom error classes for specific scenarios (e.g., AuthError, NotFoundError)

// Central error handler
// eslint-disable-next-line no-unused-vars
function apiErrorHandler(err, req, res, next) {
  const statusCode = err.statusCode || 500;
  const errorCode = err.errorCode || "INTERNAL_SERVER_ERROR";
  let message = err.message || "An unexpected error occurred.";
  const details = err.errorDetails || [];
  const type = err.errorType || "InternalServerError";
  const requestId = req.id; // Assuming req.id is set by a request ID middleware

  // In development, you might want more detailed messages
  // In production, for 500 errors, keep message generic
  if (process.env.NODE_ENV === 'production' && statusCode === 500) {
    message = "An unexpected error occurred. Please try again later.";
  }

  // Log the error (see Section 5)
  // In a real implementation, replace console.error with your structured logger (e.g., Winston, Pino) integrated with a logging service.
  console.error(`[API Error] RequestID: ${requestId}, Status: ${statusCode}, Code: ${errorCode}, Message: ${message}`, {
    error: err, // Full error object for detailed logging
    stack: err.stack,
    details: details,
    requestPath: req.path,
    requestMethod: req.method,
    // other relevant context
  });

  res.status(statusCode).json({
    error: {
      code: errorCode,
      message: message,
      details: details,
      type: type,
      requestId: requestId
    }
  });
}

// Usage in a route handler:
// app.post('/some-route', (req, res, next) => {
//   try {
//     // ... some logic ...
//     if (validationFailed) {
//       throw new ValidationError("Input validation failed", [{ field: "name", issue: "Name is required." }]);
//     }
//     // ...
//   } catch (error) {
//     next(error); // Pass to central error handler
//   }
// });

// app.use(apiErrorHandler);
```
This middleware catches errors (both explicitly thrown custom errors and unexpected errors) and formats them according to the standard.

## 5. Logging Strategy

*   **Log All Errors:** All errors handled by the centralized middleware should be logged.
*   **Logging Service:** Use a dedicated logging service in production (e.g., Google Cloud Logging, Sentry, Logtail). Avoid plain `console.error` for production environments if better tools are available.
*   **Log Content:** Each error log entry should include:
    *   Timestamp.
    *   Request ID (for tracing).
    *   Authenticated User ID / Shop ID (if available and relevant).
    *   HTTP Method and Path.
    *   Error `statusCode`, `errorCode`, `message`, `type`.
    *   Full error stack trace (especially for 5xx errors).
    *   Input parameters or request body (sanitize or omit sensitive fields like passwords, raw API keys, full credit card details, etc.).
    *   `error.details` if present.
*   **Log Levels:** Use appropriate log levels (e.g., `ERROR` for handled exceptions, `CRITICAL` or `FATAL` for unhandled exceptions if the logger supports it).
*   **Third-Party API Errors:** When errors originate from third-party APIs (Stripe, Google Ads, Gemini, PAA Service), log the original error response from that service along with your own standardized error.

## 6. Frontend Error Handling

Frontend applications (Admin Dashboard, Shopify App UI) should:

*   **Inspect HTTP Status Code:** Use the status code for general handling (e.g., 401 means redirect to login or refresh token).
*   **Parse JSON Error Response:** Access the `error.code`, `error.message`, and `error.details` for more specific actions.
*   **Display User-Friendly Messages:**
    *   For validation errors (`400`), use `error.details` to show issues next to form fields.
    *   For general errors, display `error.message` if it's deemed user-safe. Otherwise, show a generic message (e.g., "Operation failed. Please try again.").
    *   Use `error.code` to trigger specific UI behaviors if needed (e.g., show a "Plan Limit Reached - Upgrade Now" button for `PLAN_LIMIT_EXCEEDED`).
*   **Global Error Handler/Interceptor:** Implement an interceptor for API calls (e.g., in Axios or Fetch wrappers) to centrally handle common errors like 401s or network failures.
*   **Avoid Showing Raw Error Objects:** Do not display the entire JSON error object to the user.
*   **Reporting/Correlation:** If users report issues, having them provide the `error.requestId` (if displayed or easily accessible in dev tools) can greatly help in finding the corresponding backend logs.

## 7. Python PAA Service Considerations
*   The Python PAA service, if called directly by a frontend (not typical) or if its errors are not caught and re-formatted by the Node.js backend, should strive to return meaningful HTTP status codes (e.g., 400 for bad input, 500 for scraping errors).
*   If the Node.js backend is the primary consumer of the Python PAA service, the Node.js backend is responsible for:
    *   Interpreting errors from the Python service.
    *   Logging them appropriately.
    *   Transforming them into the standard API error format (defined in Section 2) before sending a response to its own client (the frontend app). For example, if the PAA service returns a 500 error, the Node.js backend might return a 502 Bad Gateway with a code like `PAA_SERVICE_ERROR`.

This global API error handling strategy will provide a consistent and robust foundation for all services within the Content Agent ecosystem.
