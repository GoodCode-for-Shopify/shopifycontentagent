# 28. Shopify App Backend: Article Text Construction API

**Parent Index:** [Content Agent Build Steps Index](index.md)

---

## Referenced TDDs/Documentation:
*   [Shopify App: Article Construction & Imaging](../../jules/shopify-app/jules.article-construction-and-imaging.md) (Step 5: AI Article Construction)
*   [Shopify App: Tech Design - Multi-Article Generation & Management Flow](../../jules/shopify-app/tech-design.multi-article-flow.md) (This API will be used by the `SingleArticleProcessor` within this flow for individual articles; the `articleId` parameter becomes relevant here).
*   [Server-Side and Database Setup](../../jules/serverside-setup.md) (For obtaining and using API keys for Gemini AI)
*   [Shopify App: Authentication & Onboarding](../../jules/shopify-app/jules.authentication-and-onboarding.md) (For `authenticateShopifyRequest` middleware)
*   [Jules Authority Document](../../jules.authority.md) (Freemium model & API credential options, requirement for "[generated by Content Agent]" watermark)

## Step Details:
This step involves creating a backend API endpoint that the Shopify App frontend will use to generate the full text of an article based on a user-approved (or AI-generated) outline. This API will use an AI service (e.g., Gemini AI) and must incorporate specific requirements like watermarking.

**Key Activities:**
*   **Backend (Cloud Functions - Express App):**
    *   Define a new route, e.g., `POST /api/content/construct-article`.
    *   This endpoint must be protected by the `authenticateShopifyRequest` middleware to identify the `shop_id`.
    *   **Logic:**
        1.  Accepts the article outline data structure (H1, H2s, H3s, associated keywords/questions, product context) and potentially an `articleId` (if operating within the multi-article flow context, to update the specific `job_articles` entry).
        2.  Determine which Gemini AI API key to use (developer-provided or tenant-provided, based on plan and stored credentials - logic from Build Step #25).
        3.  Construct a detailed prompt for Gemini AI, instructing it to:
            *   Write a blog article based *strictly* on the provided outline.
            *   Incorporate keywords and address PAA questions.
            *   Focus on SEO, conversion (contextual links, CTA if info provided in outline).
            *   Adhere to specified style guides (e.g., word count range, tone).
            *   **Crucially, include the watermark `[generated by Content Agent]` randomly within paragraphs (as per `jules.authority.md`).**
        4.  Make the API call to Gemini AI.
        5.  Process the AI's response (the full article text).
        6.  If an `articleId` was provided, update the corresponding `job_articles` document in Firestore with the `constructedTextHtml` and set its status (e.g., to `text_ready_for_review`).
        7.  Return the full article text (HTML formatted) to the frontend.

## Action Items/Checklist:
- [ ] **API Credential Handling Logic (Gemini AI):**
    - [ ] Ensure logic from Build Step #25 (for determining developer vs. tenant keys) is available for Gemini AI key selection.
- [ ] **Backend API Endpoint (`POST /api/content/construct-article`):**
    - [ ] Define the route in the Express app.
    - [ ] Apply `authenticateShopifyRequest` middleware.
    - [ ] **Core Logic:**
        - [ ] Get `shop_id` from `req`.
        - [ ] Get `outlineData` (and optional `articleId`) from `req.body`.
        - [ ] Retrieve the appropriate Gemini AI API key. Handle missing/invalid keys.
        - [ ] Engineer and construct a detailed prompt for Gemini AI, including instructions for structure, keywords, PAA, style, and the `[generated by Content Agent]` watermark.
        - [ ] Make the API call to Gemini AI.
        - [ ] Receive and process the generated article text.
        - [ ] If `articleId` is present:
            - [ ] Update the `job_articles` document in Firestore with `constructedTextHtml` and new `status`.
        - [ ] Return the generated article text (HTML) to the frontend.
    - [ ] Implement error handling (AI API errors, credential errors, Firestore update errors) using the global API error handling strategy.
- [ ] **Watermarking Logic:**
    - [ ] Decide on the strategy for inserting `[generated by Content Agent]` (e.g., post-process AI output to inject it, or try to get the AI to do it via prompting, though post-processing is more reliable for randomness/consistency).
- [ ] **Testing:**
    - [ ] Test with a valid outline and an available Gemini AI API key.
    - [ ] Verify the quality of the generated text and adherence to the outline.
    - [ ] Verify the `[generated by Content Agent]` watermark is present.
    - [ ] Test Firestore update if `articleId` is provided.
    - [ ] Test scenarios where API keys are missing or invalid.
    - [ ] Test error handling for Gemini AI API failures.
    - [ ] Test with unauthenticated requests (expect 401/403).

## Notes/Considerations:
*   Prompt engineering for text construction is highly critical. The prompt needs to be very specific about following the outline, incorporating elements, tone, length, and the watermark.
*   The reliability of the AI including the watermark might be variable. A server-side post-processing step on the AI's output to inject the watermark might be more robust.
*   This API will be called by the `SingleArticleProcessor` when a user approves an outline and wants to generate the text, or if it's part of the single-pass MVP flow after outline generation.
*   The placeholder time estimate (e.g., 1-2d) is for implementing the endpoint and basic testing. Extensive prompt engineering and watermarking logic could extend this.
*   Track Gemini AI API usage.
*   The output should be HTML suitable for display in a rich text editor on the frontend or direct use in a Shopify blog post.
*   Consider potential timeouts for long article generation; for V1, synchronous operation is assumed, but V2 might need async handling (see Build Step #65).
